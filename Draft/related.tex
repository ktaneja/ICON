\section{Related work}
\label{sec:related}

{\small $\bullet$} \textbf{Formal Specification}:
Contracts formally specify the program behavior in terms of conditions that must hold before/after and/or during the execution of a method.
A significant amount of work has been done in automated inference of contracts.
Existing approaches use program analysis~\cite{csallner08dysy,NimmerE02:ISSTA,Tillmann:2006:DLM:2105385.2105433}
to automatically infer contracts.
However, studies~\cite{Polikarpova2009ISSTA,Flanagan2001:HAA} demonstrate that a combination of developer-written and automatically extracted
contracts is the most effective approach for formally specifying the constraints on an API.

Additionally, contracts are typically in the form of assertions on the state (member variables/ properties) of a program. In contrast, temporal constraints specify the ordering of method invocations, therefore are different.
Furthermore, since \tool\ infers temporal constraints from API documents, we envision \tool\ to work in conjunction with existing approaches
to infer a comprehensive formal specification.
 
Another set of approaches infer code-contract-like specifications (such as behavioral model, algebraic specifications, and exception specifications) either dynamically\cite{Henkel07discoveringdocumentation,Ghezzi:2009:SIB:1555001.1555057,Henkel:2008:DDA:1363102.1363105} or statically~\cite{Flanagan2001:HAA,Buse:2008:ADI:1390630.1390664,wasylkowski2011mining} from source code and binaries. 
Among mining based approaches Gable and Su~\cite{gabel2008javert} proposed to learn  
\textit{micro-patterns} of temporal properties from runtime traces and then combining them into larger specifications depicted as finite state automata.
In contrast, \tool\ infers specifications from the natural language text in API documents,
thus complementing existing approaches when the source code or binaries of the API library is not available.


{\small $\bullet$} \textbf{NLP in Software Engineering (SE)}:
Research advances~\cite{Marneffe08COLING,KleinNIPS03} in the accuracy of existing NLP techniques have inspired researchers and practitioners~\cite{pandita12:inferring, pandita13:WHYPER, johnSlankasPASSAT13, XiaoFSE2012, thummalapentaICSE12} to adapt and(/or) apply NLP techniques to solve problems in SE domain. 
Tan et al.~\cite{TanSOSP07} were the first to apply ML and NLP on code comments to detect mismatches between the comments and the implementation.
They rely on predefined rule templates targeted towards threading and lock related comments, and then apply ML-based approach to find comments following such rules.
The constraints inferred by their approach are the restrictions imposed by the developer on the client code.
In comparison, the temporal constraints inferred by \tool\ are the restriction imposed by the API library being used by the client code.

Zhong et al.~\cite{zhong09SE} also leverage ML along with type information to infer constraints on resources from API documents.
Specifically, their approach infers resource constraints following the template - ``\textit{resource creation methods} followed by \textit{resource manipulation methods} followed by \textit{resource release methods}''.
However, temporal constraints are often not be limited to such template. 
Furthermore, the these approaches rely on specific templates for inferring constraints. In contrast, \tool\ works independent of such templates for identifying constraints.


Xiao et al.~\cite{XiaoFSE2012} and Slankas et al.~\cite{johnSlankasPASSAT13} use shallow parsing techniques to infer Access Control Policy (ACP) rules from natural language text in use cases. In contrast, the \tool\ approach works with API documents.
Our previous work~\cite{pandita12:inferring} proposed an NLP-based approach on inferring parameter constraints from method descriptions in the API documents. \tool\ differs from previous work as follows.
\tool\ addresses the problem of inferring temporal constraint, which is not addressed by the previous approach. \tool\ significantly extends the infrastructure in following dimensions.
First, \tool\ relies on ML to identify the temporal constraint sentences. The lower frequency of occurrence of temporal constraint sentences in comparison to parameter constraint sentences, make them harder to detect.
Second, the \tool\ approach introduces hybrid shallow parsing that relies both on parts-of-speech tags as well as Stanford-typed dependencies to construct intermediate representation, while the previous approach relies only on parts-of-speech tags.
Finally, the \tool\ approach leverages the concept of semantic graphs constructed from class and method names in API to automatically infer the implicit method references in a sentence. 


{\small $\bullet$} \textbf{Augmented Documentation}:
Dekel and Herbsleb~\cite{Dekel2009}, were the first to create a tool namely eMoose,
an Eclipse IDE based plug-in that allowed developers to create directives
(way of marking the specification sentences) in the default API documentation.
These directives are highlighted whenever they are displayed in the Eclipse environment.
Lee et al.~\cite{lee2012towards} improved upon their work by providing a formalism to the directives proposed by Dekel et al.~\cite{Dekel2009},
thus allowing tool-based verification.
However, a developer has to manually annotate such directives.
In contrast, \tool\ both identifies the sentences pertaining to temporal constraints and infers the temporal constraints automatically.