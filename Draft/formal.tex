%\subsection{Temporal Specifications}
%\label{sub:temporal}
%
%We next describe various classes of temporal constraints using formal temporal logic.
%Temporal logic is a system of rules and symbols that are used to express and reason about prepositions pertaining to time.
%We next present an extension to the temporal logic for API method invocation related rules proposed by Lo et al.~\cite{lo2009mining}
%
%\textbf{Method Invocation}: 
%We adapt the definition of events proposed by Lo et al.~\cite{lo2009mining} as method invocation.
%They define event as \textit{``any concrete or abstract representation of a program state''}. 
%We propose the notion of method invocation analogous to the events,
%where each method invocation is represented as a tuple which is an ordered set of strings. 
%A method invocation is captured as the Tuple \CodeIn{<T> <str1, str2, str3... >}, where \CodeIn{str1, str2, str3}... are string values,
%that belong to set of all strings.
%The method invocation tuple \CodeIn{<T>} captures information about the return value, enclosing type, name, and the parameter types of the method.
%Therefore a tuple \CodeIn{<T> <String, Bar, foo, Integer, Integer>} represents a method \CodeIn{foo} enclosed by the type \CodeIn{Bar},
%that accepts two parameters of type \CodeIn{Integer} and a return value of type \CodeIn{String}. 
%For better readability mnemonic representation of the preceding tuple is \CodeIn{String<-Bar.foo(Integer, Integer);}
%
%
%\textbf{Method Invocation Predicates}: We define method predicate as a predicate $E$ over method invocations.
%We reuse the notations proposed by Lo et al.~\cite{lo2009mining} $m \vdash \xi$ to denote that method invocation $m$ satisfies method predicate $\xi$.
%In context of \tool, method predicates combines a method name and the enclosing type with potential constraints on the return types and parameter types. 
%The predicates are modeled after \textit{equality constraints predicates}, and are represented as \CodeIn{\$i=sym}, where \CodeIn{i} is a non-negative integer and \CodeIn{sym} is the primitive string value and defined as: a method invocation $m$ satisfies a predicates \CodeIn{\$i=sym} iff \CodeIn{m[i]=sym}. The simplest form of these predicates is of type \CodeIn{\$2 = sym} which refer to method invocations of name \CodeIn{sym}.
%
%\textbf{Temporal Operators}: Temporal constraints~\footnote{Temporal formulae} are constructed by combining method invocation predicates using temporal operators. Lo et al.~\cite{lo2009mining}, proposed the following temporal operators:   
%
%\begin{enumerate}
%
%\item \textit{Forward Eventual Operator ($\xi_1 \xrightarrow{*} \xi_2$)}:
%occurrence of $\xi_1$ must be eventually followed by occurrence of $\xi_2$
%
%\item \textit{Backward Eventual Operator: ($\xi_1 \xleftarrow{*} \xi_2$)}:
%occurrence of $\xi_1$ must be preceded by occurrence of $\xi_2$
%
%\item \textit{Forward Alternation Operator ($\xi_1 \xrightarrow{a} \xi_2$)}:
%occurrence of $\xi_1$ must be eventually followed by occurrence of $\xi_2$ and $\xi_1$ cannot occur in between
%
%\item \textit{Backward Alternation Operator ($\xi_1 \xleftarrow{a} \xi_2$)}:
%occurrence of $\xi_1$ must be preceded by occurrence of $\xi_2$ and $\xi_1$ cannot occur in between
%\end{enumerate}
%
%\textbf{Quantification}: Quantification is used to introduce constraints involving parameter and return types of a method invocation. Formal representation of temporal constraints are obtained by varying: 1) the temporal operators allowed, b) the method-invocation predicates allowed, and 3) the degree of quantification allowed. For instance, consider the constraint any method in an enclosing type \CodeIn{Obj} must not be invoked after method \CodeIn{foo} in the \CodeIn{Obj}: $\forall$ \CodeIn{m <m in Obj> !=<foo in Obj>}.
