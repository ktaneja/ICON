\subsection{Temporal Specifications}
\label{sub:temporal}

We next describe various classes of temporal constraints using formal temporal logic.
Temporal logic is a system of rules and symbols that are used to express and reason about prepositions pertaining to time.
We next present an extension to the temporal logic for API method invocation related rules proposed by Lo et al.~\cite{lo2009mining}

\textbf{Method Invocation}: 
We adapt the definition of events proposed by Lo et al.~\cite{lo2009mining} as method invocation.
They define event as \textit{``any concrete or abstract representation of a program state''}. 
We propose the notion of method invocation analogous to the events,
where each method invocation is represented as a tuple which is an ordered set of strings. 
A method invocation is captured as the Tuple \CodeIn{<T> <str1, str2, str3... >}, where \CodeIn{str1, str2, str3}... are string values,
that belong to set of all strings.
The method invocation tuple \CodeIn{<T>} captures information about the return value, enclosing type, name, and the parameter types of the method.
Therefore a tuple \CodeIn{<T> <String, Bar, foo, Integer, Integer>} represents a method \CodeIn{foo} enclosed by the type \CodeIn{Bar},
that accepts two parameters of type \CodeIn{Integer} and a return value of type \CodeIn{String}. 
For better readability mnemonic representation of the preceding tuple is \CodeIn{String<-Bar.foo(Integer, Integer);}


\textbf{Method Invocation Predicates}: We define method predicate as a predicate $E$ over method invocations.
We reuse the notations proposed by Lo et al.~\cite{lo2009mining} $m \vdash \xi$ to denote that method invocation $m$ satisfies method predicate $\xi$.
In context of \tool, method predicates combines a method name and the enclosing type with potential constraints on the return types and parameter types. 
The predicates are modeled after \textit{equality constraints predicates}, and are represented as \CodeIn{\$i=sym}, where \CodeIn{i} is a non-negative integer and \CodeIn{sym} is the primitive string value and defined as: a method invocation $m$ satisfies a predicates \CodeIn{\$i=sym} iff \CodeIn{m[i]=sym}. The simplest form of these predicates is of type \CodeIn{\$2 = sym} which refer to method invocations of name \CodeIn{sym}.

\textbf{Temporal Operators}: Temporal constraints~\footnote{Temporal formulae} are constructed by combining method invocation predicates using temporal operators. Lo et al.~\cite{lo2009mining}, proposed the following temporal operators:   

\begin{enumerate}

\item \textit{Forward Eventual Operator ($\xi_1 \xrightarrow{*} \xi_2$)}:
occurrence of $\xi_1$ must be eventually followed by occurrence of $\xi_2$

\item \textit{Backward Eventual Operator: ($\xi_1 \xleftarrow{*} \xi_2$)}:
occurrence of $\xi_1$ must be preceded by occurrence of $\xi_2$

\item \textit{Forward Alternation Operator ($\xi_1 \xrightarrow{a} \xi_2$)}:
occurrence of $\xi_1$ must be eventually followed by occurrence of $\xi_2$ and $\xi_1$ cannot occur in between

\item \textit{Backward Alternation Operator ($\xi_1 \xleftarrow{a} \xi_2$)}:
occurrence of $\xi_1$ must be preceded by occurrence of $\xi_2$ and $\xi_1$ cannot occur in between
\end{enumerate}

\textbf{Quantification}: Quantification is used to introduce constraints involving parameter and return types of a method invocation. Formal representation of temporal constraints are obtained by varying: 1) the temporal operators allowed, b) the method-invocation predicates allowed, and 3) the degree of quantification allowed. For instance, consider the constraint any method in an enclosing type \CodeIn{Obj} must not be invoked after method \CodeIn{foo} in the \CodeIn{Obj}: $\forall$ \CodeIn{m <m in Obj> !=<foo in Obj>}.
